<center><h1>bool类型（布尔类型）</h1></center>

---

一个布尔类型的值只有两种：true 和 false。if 和 for 语句的条件部分都是布尔类型的值，并且 == 和 < 等比较操作也会产生布尔型的值。

一元操作符 ! 对应逻辑非操作，因此 !true 的值为 false，更罗嗦的说法是 (!true==false) ==true，虽然表达方式不一样，不过我们一般会采用简洁的布尔表达式，就像用 x 来表示 x==true。

```go
var aVar = 10
aVar == 5  // false
aVar == 10 // true
aVar != 5  // true
aVar != 10 // false
```

Go 语言对于值之间的比较有非常严格的限制，只有两个类型相同的值才可以进行比较，如果值的类型是接口（interface），它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值的类型必须和该常量类型相兼容的。如果以上条件都不满足，则其中一个值的类型必须在被转换为和另外一个值的类型相同之后才可以进行比较。

布尔值可以和 &&（AND）和 ||（OR）操作符结合，并且有短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：

```go
s != "" && s[0] == 'x'
```

其中 s[0] 操作如果应用于空字符串将会导致 panic 异常。

因为 && 的优先级比 || 高（&& 对应逻辑乘法，|| 对应逻辑加法，乘法比加法优先级要高），下面形式的布尔表达式是不需要加小括弧的：

```go
if 'a' <= c && c <= 'z' ||
    'A' <= c && c <= 'Z' ||
    '0' <= c && c <= '9' {
    // ...ASCII字母或数字...
}
```

布尔值并不会隐式转换为数字值 0 或 1，反之亦然。必须使用一个显式的 if 语句辅助转换：

```go
i := 0
if b {
    i = 1
}
```

如果需要经常做类似的转换, 包装成一个函数会更方便:

```go
// 如果b为真，btoi返回1；如果为假，btoi返回0
func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}
```

数字到布尔型的逆转换则非常简单, 不过为了保持对称, 我们也可以包装一个函数:

```go
// itob报告是否为非零。
func itob(i int) bool { return i != 0 }
```

Go 语言中不允许将整型强制转换为布尔型，代码如下：

```go
var n bool
fmt.Println(int(n) * 2)
```

编译错误，输出如下：

```
cannot convert n (type bool) to type int
```

布尔型无法参与数值运算，也无法与其他类型进行转换。
