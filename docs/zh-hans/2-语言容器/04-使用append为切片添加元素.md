<center><h1>使用append()为切片添加元素</h1></center>

---

Go 语言的内建函数 append() 可以为切片动态添加元素，代码如下所示：

```go
var a []int
a = append(a, 1) // 追加1个元素
a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式
a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包
```

不过要注意的是，在容量不足的情况下， append 的操作会导致重新分配内存（扩容），可能导致巨大的内存分配和复制数据代价。即使容量足够，依然需要用 append 函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。

切片在扩容时，容量的扩展规律按容量的 2 倍数扩充，例如 1、2、4、8、16……，代码如下：

```go
var numbers []int

for i := 0; i < 10; i++ {
    numbers = append(numbers, i)
    fmt.Printf("len: %d  cap: %d pointer: %p\n", len(numbers), cap(numbers), numbers)
}
```

代码输出如下：

```
len: 1 cap: 1 pointer: 0xc0420080e8

len: 2 cap: 2 pointer: 0xc042008150

len: 3 cap: 4 pointer: 0xc04200e320

len: 4 cap: 4 pointer: 0xc04200e320

len: 5 cap: 8 pointer: 0xc04200c200

len: 6 cap: 8 pointer: 0xc04200c200

len: 7 cap: 8 pointer: 0xc04200c200

len: 8 cap: 8 pointer: 0xc04200c200

len: 9 cap: 16 pointer: 0xc042074000

len: 10 cap: 16 pointer: 0xc042074000
```

代码说明如下：

```
第 1 行，声明一个整型切片。
第 4 行，循环向 numbers 切片添加10个数。
第 5 行中，打印输出切片的长度、容量和指针变化。使用 len() 函数查看切片拥有的元素个数，使用 cap() 函数查看切片的容量情况。
```

通过查看代码输出，有一个有意思的规律：len() 函数并不等于 cap。

往一个切片中不断添加元素的过程，类似于公司搬家。公司发展初期，资金紧张，人员很少，所以只需要很小的房间即可容纳所有的员工。随着业务的拓展和收入的增加就需要扩充工位，但是办公地的大小是固定的，无法改变。因此公司选择搬家，每次搬家就需要将所有的人员转移到新的办公点。

```
员工和工位就是切片中的元素。
办公地就是分配好的内存。
搬家就是重新分配内存。
无论搬多少次家，公司名称始终不会变，代表外部使用切片的变量名不会修改。
因为搬家后地址发生变化，因此内存“地址”也会有修改。
```

除了在切片的尾部追加，我们还可以在切片的开头添加元素：

```go
var a = []int{1,2,3}
a = append([]int{0}, a...) // 在开头添加1个元素
a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片
```

在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制 1 次。因此，从切片的开头添加元素的性能一般要比从尾部追加元素的性能差很多。

由于 append 函数返回新的切片，也就是它支持链式操作。可以将多个 append 操作组合起来，实现在切片中间插入元素：

```go
var a []int
a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第i个位置插入x
a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片
```

每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i] 。
